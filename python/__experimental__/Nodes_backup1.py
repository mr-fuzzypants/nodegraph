# THIS IS PRE-REFACTORING CODE. DO NOT EDIT THIS FILE (JAN 14,2026)

import sys
from collections import OrderedDict

PORT_TYPE_INPUT = 1
PORT_TYPE_OUTPUT = 2   
PORT_TYPE_INPUTOUTPUT = 4   # this is a passthrough port for nodenetworks. Passing from input to output directly
PORT_TYPE_OUTPUTINPUT = 8   # this is a passthrough port for nodenetworks. Passing from output to input directly
PORT_TYPE_RESERVED4 = 16
PORT_TYPE_RESERVED5 = 32
PORT_TYPE_RESERVED6 = 64
PORT_TYPE_CONTROL = 0x80

CONTROL_PORT = 0
DATA_PORT = 1
ANY_PORT = 2




# A typescript map behaves like an ordered dict in python
class Node:
    def __init__(self, id, type, owner=None, inputs=None, outputs=None):
        self.id = id
        self.type = type

        # TODO: should I seperate out data inputs/outputs from control inputs/outputs?
        self.inputs = inputs if inputs is not None else OrderedDict()
        self.outputs = outputs if outputs is not None else OrderedDict()

        self.is_flow_control_node = False

        self.is_loop_node = False # set to true for loop nodes

        self._isDirty = True  

        self.owner = owner  # Placeholder for node network that owns this node

    def isNetwork(self):
        return False

    def isDataNode(self):
        return self.is_flow_control_node == False

    def isFlowControlNode(self):
        return self.is_flow_control_node == True
    
    def markDirty(self):
        self._isDirty = True
        
    def markClean(self):
        self._isDirty = False

    def isDirty(self):  
        return self._isDirty

    def delete_input(self, port_name):
        if port_name in self.inputs:
            # TODO: we need to handle what a control port deletion means for the node
            # and what it means fror is_flow_control_node flag
            #if self.inputs[port_name].isControlPort():
            #    self.is_flow_control_node = False

            for connection in self.inputs[port_name].connections:
                # remove connection from the other port as well
                from_port = connection.from_port
                for conn in from_port.connections:
                    if conn.to_port == self.inputs[port_name]:
                        from_port.connections.remove(conn)
                        break


            del self.inputs[port_name]    

    def delete_output(self, port_name):
        if port_name in self.outputs:
            del self.outputs[port_name]

    def add_input(self, port_name, port_type, is_control=False):
        port = NodePort(self, port_name, port_type, is_control)
        self.inputs[port_name] = port
        return port

    def add_output(self, port_name, port_type, is_control=False):
        port = NodePort(self, port_name, port_type, is_control)
        self.outputs[port_name] = port
        return port
    
    def add_control_input(self, port_name):
        port = ControlPort(self, port_name, PORT_TYPE_INPUT)
        self.inputs[port_name] = port
        return port
    
        # TODO: was this. is it better?
        #self.is_flow_control_node = True
        #return self.add_input(port_name, PORT_TYPE_INPUT, is_control=True)

    def add_control_output(self, port_name):

        port = ControlPort(self, port_name, PORT_TYPE_OUTPUT)
        self.outputs[port_name] = port
        return port
    
        # TODO: was this. is it better?
        #self.is_flow_control_node = True
        #return self.add_output(port_name, PORT_TYPE_OUTPUT, is_control=True)
    

    def add_data_input(self, port_name):
        if port_name in self.inputs:
            raise ValueError(f"Data input port '{port_name}' already exists in node '{self.id}'")
        
        port = DataPort(self, port_name, PORT_TYPE_INPUT)
        self.inputs[port_name] = port

        return port

        # TODO: was this: (is it better?)
        #return self.add_input(port_name, PORT_TYPE_INPUT, is_control=False)
    
    def add_data_output(self, port_name):
        if port_name in self.outputs:
            raise ValueError(f"Data output port '{port_name}' already exists in node '{self.id}'")
        
        port = DataPort(self, port_name, PORT_TYPE_OUTPUT)
        self.outputs[port_name] = port

        return port


    # restrict_to filters out coontrol, data or both port types
    def get_input_ports(self, restrict_to=None):
        if restrict_to is None:
            return list(self.inputs.values())
        else:
            if restrict_to == CONTROL_PORT:
                return [port for port in self.inputs.values() if port.port_type & PORT_TYPE_CONTROL != 0]
            elif restrict_to == DATA_PORT:
                return [port for port in self.inputs.values() if port.port_type & PORT_TYPE_CONTROL == 0 ]
            else:
                return []
            
    def get_output_ports(self, restrict_to=None):
        if restrict_to is None:
            return list(self.outputs.values())
        else:
            if restrict_to == CONTROL_PORT:
                return [port for port in self.outputs.values() if port.port_type & PORT_TYPE_CONTROL != 0 ]
            elif restrict_to == DATA_PORT:
                return [port for port in self.outputs.values() if port.port_type & PORT_TYPE_CONTROL == 0 ]
            else:
                return []
            
    def get_output_data_ports(self):
        return self.get_output_ports(restrict_to=DATA_PORT)

    def get_output_control_ports(self):
        return self.get_output_ports(restrict_to=CONTROL_PORT)  

    def get_input_data_ports(self):
        return self.get_input_ports(restrict_to=DATA_PORT)

   
    def get_input_control_ports(self):
        return self.get_input_ports(restrict_to=CONTROL_PORT)
        

    def get_input_data_port(self, port_name): 
        port = self.inputs.get(port_name)
        if not port:
            raise ValueError(f"Input port '{port_name}' not found in node '{self.id}'")
        if not port.isDataPort():
            raise ValueError(f"Input port '{port_name}' in node '{self.id}' is not a data port")
        
        return port
    
    def get_output_data_port(self, port_name):
        port = self.outputs.get(port_name)
        if not port:
            raise ValueError(f"Output port '{port_name}' not found in node '{self.id}'")
        if not port.isDataPort():
            raise ValueError(f"Output port '{port_name}' in node '{self.id}' is not a data port")
        
        return port
    
    def get_input_control_port(self, port_name):
        port = self.inputs.get(port_name)
        if not port:
            print(self.id, self.type)
            for p in self.inputs:
                print("  Input port:", p.port_name, "type:", p.port_type)
            raise ValueError(f"Input port '{port_name}' not found in node '{self.id}'")
        if not port.isControlPort():
            raise ValueError(f"Input port '{port_name}' in node '{self.id}' is not a control port")
        
        return port
    
    def get_output_control_port(self, port_name):
        port = self.outputs.get(port_name)
        if not port:
            raise ValueError(f"Output port '{port_name}' not found in node '{self.id}'")
        if not port.isControlPort():
            raise ValueError(f"Output port '{port_name}' in node '{self.id}' is not a control port")
        
        return port

    def get_source_nodes(self, port_name):
        port = self.inputs.get(port_name)
        if not port:
            raise ValueError(f"Input port '{port_name}' not found in node '{self.id}'")
        
        source_nodes = []
        for connection in port.connections:
            source_nodes.append(connection.from_node)
        return source_nodes
    
    def get_target_nodes(self, port_name):
        port = self.outputs.get(port_name)
        if not port:
            raise ValueError(f"Output port '{port_name}' not found in node '{self.id}'")
        
        target_nodes = []
        for connection in port.connections:
            target_nodes.append(connection.to_node)
        return target_nodes
    

    def can_connect_output_to(self, from_port_name, other_node, to_port_name):
        from_port = self.outputs.get(from_port_name)
        to_port = other_node.inputs.get(to_port_name)

        if not from_port:
            raise ValueError(f"Output port '{from_port_name}' not found in node '{self.id}'")
        if not to_port:
            raise ValueError(f"Input port '{to_port_name}' not found in node '{other_node.id}'")
        
        if from_port.node == other_node:
            return False
        
        return True

    def connect_output_to(self, from_port_name, other_node, to_port_name):
        from_port = self.outputs.get(from_port_name)
        to_port = other_node.inputs.get(to_port_name)

        if not from_port:
            raise ValueError(f"Output port '{from_port_name}' not found in node '{self.id}'")
        if not to_port:
            raise ValueError(f"Input port '{to_port_name}' not found in node '{other_node.id}'")
        
        if from_port.node == other_node:
            raise ValueError("Cannot connect a node's output to its own input")
        

        if to_port.connections:
            if to_port.isInputOutputPort() or from_port.isInputOutputPort():
                # allow multiple connections for input/output ports
                pass
            else:
                raise ValueError(f"Error: Input port '{to_port_name}' on node '{other_node.id}' is already connected")
        

        from_port.connectTo(to_port)
        #outbound_connection = Connection(self, from_port, other_node, to_port)
        #from_port.addConnection(outbound_connection)


        #o_port.addConnection(Connection(other_node, to_port, self, from_port))
        #to_port.addConnection(outbound_connection)
        #return outbound_connection
    

    
  

    # TODO: precompute should not compute inputs. this should be done in compute() and this should be a callback only
    def precompute(self):
        pass

    def postcompute(self):
        # validation checks. We're really just making sure the node is working correclty here.
        self.dump_dirty_states()
        assert(self.all_data_inputs_clean())
        
        assert(self.all_data_outputs_clean())


        self._isDirty = False
        


    # this is checking for cleen DATA inputs only
    def all_data_inputs_clean(self):
        for input_port in self.get_input_data_ports():
            if input_port._isDirty:
                return False
        return True
    

    def all_data_outputs_clean(self):
        for output_port in self.get_output_data_ports():
            if output_port._isDirty:
                return False
        return True
    
    def dump_dirty_states(self):
        print(f"Node [{self.id}] dirty states:")
        for input_port in self.get_input_data_ports():
            print(f"  Input Port [{input_port.port_name}] dirty: {input_port.isDirty()}")
        for output_port in self.get_output_data_ports():
            print(f"  Output Port [{output_port.port_name}] dirty: {output_port.isDirty()}")

    

    def compute(self):
        self.precompute()

        self.postcompute()

       
    
        # if any inputs are still dirty, we cannot compute this node
        # if any input ports have changed then recompute.

        pass  # Placeholder for node computation logic

    def generate_IRC(self):
        # Placeholder for generating intermediate representation code for this node
        pass


class NodeNetwork(Node):
    def __init__(self, id, owner=None):
        super().__init__(id, type="NodeNetwork")
        self.nodes = OrderedDict()

        self.owner = owner  # Placeholder for higher-level owner (if any)
    
    def isNetwork(self):
        return True

    def isRootNetwork(self):
        return self.owner is None

    def isSubnetwork(self):
        return self.owner is not None

    def add_node(self, node):
        self.nodes[node.id] = node
    
    def get_node(self, node_id):
        return self.nodes.get(node_id)
    
    def add_control_inputouput_port(self, port_name):
        if port_name in self.inputs:
            raise ValueError(f"Data input port '{port_name}' already exists in node '{self.id}'")
         
        port = ControlPort(self, port_name, PORT_TYPE_INPUTOUTPUT)
        self.inputs[port_name] = port
        return port

    def add_control_outputinput_port(self, port_name):
        if port_name in self.inputs:
            raise ValueError(f"Data input port '{port_name}' already exists in node '{self.id}'")

        port = ControlPort(self, port_name, PORT_TYPE_OUTPUTINPUT)
        self.outputs[port_name] = port
        return port
    
       

    def add_data_inputoutput_port(self, port_name):
        if port_name in self.inputs:
            raise ValueError(f"Data input port '{port_name}' already exists in node '{self.id}'")
        
        port = DataPort(self, port_name, PORT_TYPE_INPUTOUTPUT)
        self.inputs[port_name] = port

        return port

    
    def add_data_outputinput_port(self, port_name):
        if port_name in self.outputs:
            raise ValueError(f"Data output port '{port_name}' already exists in node '{self.id}'")
        
        port = DataPort(self, port_name, PORT_TYPE_OUTPUTINPUT)
        self.outputs[port_name] = port

        return port
    

    def compute_step(self, start_nodes=None):
        # If start_nodes is provided, only compute from those nodes):

        if start_nodes:
            compute_nodes = start_nodes
            for cur_node in compute_nodes:
                print("Computing from start node:", cur_node.id)
                cur_node.compute()

            for cur_node in compute_nodes:           
                # find next nodes to compute based on control flow
                next_nodes = []
                print("Finding next nodes to compute...")
                for output_port in cur_node.get_output_control_ports():
                    print("Output control port:", output_port.port_name)
                    for connection in output_port.connections:
                        print("  connection to node:", connection.to_port.node.id, connection.to_port.isActive() )
                        if connection.to_port.isActive():
                            next_node = connection.to_port.node
                            #if not next_node.is_loop_node:
                            next_nodes.append(connection.to_port.node)

            #for next_node in next_nodes:
            #    next_node.compute()
            return next_nodes
            #self.compute(next_nodes)

    def compute(self, start_nodes=None):


        next_nodes = start_nodes
        while (1):
            next_nodes = self.compute_step(next_nodes)
            if not next_nodes:
                break

            #self.markClean()

    def createNetwork(self, id):

        if self.nodes.get(id):
            raise ValueError(f"Node with id '{id}' already exists in the network")
        network = NodeNetwork(id=id, owner=self)
        self.add_node(network)

        return network

    # TODO: this should be node factory
    def createNode(self, id, type):

        if self.nodes.get(id):
            raise ValueError(f"Node with id '{id}' already exists in the network")
        
        if type == "Parameter":
            node = ParamNode(id, type, value=0)
        elif type == "Message":
            node = MessageNode(id, type)
        else:
            raise ValueError(f"Unknown node type '{type}'")

        #node = Node(id, type, owner=self)
        self.add_node(node)
        return node

    def connectNodes(self, from_node_id, from_port_name, to_node_id, to_port_name):
        from_node = self.get_node(from_node_id)
        to_node = self.get_node(to_node_id)

        if not from_node:
            raise ValueError(f"Source node with id '{from_node_id}' does not exist in the network")
        if not to_node:
            raise ValueError(f"Target node with id '{to_node_id}' does not exist in the network")
        
        connection = from_node.connect_output_to(from_port_name, to_node, to_port_name)
        return connection
    
    def deleteNode(self, id):
        if not self.nodes.get(id):
            raise ValueError(f"Node with id '{id}' does not exist in the network")
        # TODO: deleting a node involves removing all connections to/from it first
        del self.nodes[id]
    

    
class ParamNode(Node):
    def __init__(self, id, type, value):
        super().__init__(id, type)

        self.dout_value = self.add_data_output('value')

        self.param_value = value
        


    def compute(self):
        super().precompute()

        # For a parameter node, we might just set a default value
        self.dout_value.setValue(self.param_value)
        self.markClean()
        self._isDirty = False
        print("....ParameterNode:", self.id, "set value to", self.param_value, self.dout_value.isDirty(), )

        super().postcompute()

    def generate_IRC(self, irc_builder):
        """
        Docstring for generate_IRC
        
        :param self: Description
        :param irc_builder: Description
        """ 
        
        val = str(self.param_value)
        result = irc_builder.new_temp()
        irc_builder.emit("CONST", val, "->", result)

        return result
        


class AddNode(Node):
    def __init__(self, id, type):
        super().__init__(id, type)

        self.din_a = self.add_data_input('a')
        self.din_b = self.add_data_input('b')
        self.dout_result = self.add_data_output('result')


    def compute(self):
        super().precompute()

        
        a = self.din_a.getValue()
        b = self.din_b.getValue()

        if self.all_data_inputs_clean():
            self.dout_result.setValue(a + b)  # Example operation
        else:
            raise ValueError(f"Cannot compute '{self.type}' '{self.id}' because inputs are dirty")
        super().postcompute()
    

class LessThanNode(Node):
    def __init__(self, id, type):
        super().__init__(id, type)

        self.din_a = self.add_data_input('a')
        self.din_b = self.add_data_input('b')
        self.dout_result = self.add_data_output('result')


    def compute(self):
        self.precompute()
       
        a = self.din_a.getValue()
        b = self.din_b.getValue()

        if self.all_data_inputs_clean():
            self.dout_result.setValue(a < b)
        else:
            raise ValueError(f"Cannot compute LessThanNode '{self.id}' because inputs are dirty")
            
        super().postcompute()

class IfNode(Node):
    def __init__(self, id, type):
        super().__init__(id, type)

        self.cin_exec = self.add_control_input('exec')
        self.din_condition = self.add_data_input('condition')
        self.cout_true = self.add_control_output('true')
        self.cout_false = self.add_control_output('false')

        self.is_flow_control_node = True

    def compute(self):
        super().precompute()

        if self.cin_exec.isActive():
            self.cin_exec.deactivate()
        
         
            condition = self.din_condition.getValue()
            
            if self.all_data_inputs_clean():
                if condition:
                    self.cout_true.activate()
                    self.cout_false.deactivate()
                else:
                    self.cout_false.activate()
                    self.cout_true.deactivate()
            else:
                raise ValueError(f"Cannot compute IfNode '{self.id}' because inputs are dirty")
        
        super().postcompute()

class LoopNode(Node):
    def __init__(self, id, type):
        super().__init__(id, type)

        self.cin_exec = self.add_control_input('exec')
        self.cout_body = self.add_control_output('body')
        self.cout_completed = self.add_control_output('completed')

        self.din_start = self.add_data_input('start')
        self.din_end = self.add_data_input('end')
        self.din_step = self.add_data_input('step')
        self.dout_index = self.add_data_output('index')

        self.initalized = False
        self.is_loop_node = True
        self.index = 0

        self.is_flow_control_node = True

    def check_end_condition(self):
        if self.index >= self.index_end:
            return True
        return False
    
    def initialize_loop(self):
        print("Initializing loop node")
        # make copies of the loop parameters so that they don't change during the loop execution
        # (For this demo, we assume inputs are clean/ready)
        self.index_start = self.din_start.getValue()
        self.index = self.index_start
   
        self.index_end = self.din_end.getValue()
        self.index_step = self.din_step.getValue()
        self.initalized = True

        # initialize output index port
        self.dout_index.setValue(self.index)
        self.cout_completed.deactivate()
        print(f"  Loop Params: start={self.index_start}, end={self.index_end}, step={self.index_step}")

    def increment_loop(self):
        self.index += self.index_step
        
        # print(" ---- Loop index incremented to:", self.index)

    def execute_body(self):
        """
        Synchronously executes the chain of nodes connected to the 'body' output.
        This mimics the 'Implicit Loop' macro behavior of Unreal Engine.
        """
        # 1. Identify start nodes attached to 'body'
        start_nodes = []
        body_port = self.cout_body
        
        # Activate the port (visuals/logic)
        body_port.activate()
        
        # Collect connected nodes
        for conn in body_port.connections:
            start_nodes.append(conn.to_node)
        
        # 2. Run them (Simple BFS runner)
        # Note: This is a localized runner that mimics NodeNetwork.compute but strictly for the body chain
        current_queue = start_nodes
        
        while current_queue:
            next_step_nodes = []
            
            for node in current_queue:
                # Run the node
                node.compute()
                print("********* computed node:", node.id)
                
                # Check control outputs to continue the chain
                for out_port in node.get_output_control_ports():
                    print(" ********Checking output control port:", out_port.port_name, "active:", out_port.isActive())
                    if out_port.isActive():
                        # Consume signal so it doesn't leak or re-trigger
                        out_port.deactivate()
                        
                        # Add downstream nodes to queue
                        for conn in out_port.connections:
                            # Propagate signal
                            conn.to_port.setValue(True)
                            next_step_nodes.append(conn.to_node)
                            print(" ******* Added node to next step:", conn.to_node.id)
            
            current_queue = next_step_nodes

    def compute(self):
        print("LoopNode compute call started...")
        super().precompute() 

        if self.cin_exec.isActive():
            self.cin_exec.deactivate()
            
            self.initialize_loop()

            if self.all_data_inputs_clean():
                # IMPLICIT LOOP EXECUTION
                # Run the entire loop synchronously.
                # TODO: these really should be asynchronous calls where the body execution yields back to the loop node
                while not self.check_end_condition():
                    # Update index
                    
                    self.dout_index.setValue(self.index)

                    self.execute_body()
                    
                    # Increment
                    self.increment_loop()
                self.cout_completed.activate()
            else:
                raise ValueError(f"Cannot compute LoopNode '{self.id}' because inputs are dirty")
            
            self.initalized = False

        #self._isDirty = False # Mark node as clean after a compute.
        super().postcompute()


class MessageNode(Node):
    def __init__(self, id, type):
        super().__init__(id, type)

        self.cin_msg = self.dataport_msg = self.add_data_input('msg')
        self.cin_exec = self.controlport_exec = self.add_control_input('exec')
        self.cout_next = self.controlport_next = self.add_control_output('next')

        self.is_flow_control_node = True
 

    def get_dataport_value(self, port):
        return port.connections[0].from_port.value
    
    def compute(self):
        super().precompute()

        # here we're forcing the port to contain a value and cleaning the port.
        # this is a test.
       
        #msg = self.dataport_msg.connections[0].from_port.value
        if self.cin_exec.isActive():
            self.cin_exec.deactivate()
            msg = self.dataport_msg.getValue()
            print("                  +++++++++++++++++=MessageNode:", msg)  # Example action
        
            self.cout_next.activate()

            # TODO: this is error prone
            #self._isDirty = False # Mark node as clean after a compute.

        super().postcompute()

class LogNode(Node):
    def __init__(self, id, type):
        super().__init__(id, type)

        self.add_data_input('msg')
        self.add_control_input('exec')

        self.is_flow_control_node = True

    def compute(self):
        print("LogNode compute called")
        super().precompute()

        # TODO: remvove this later. we're forcing the port to contain a value and cleaning the port.
        # we can use something similar for default values later in case the port isn't connected to anything.
        msgPort = self.inputs['msg']
        msgPort.value = "Hello, World!"  # Example message
        msgPort._isDirty = False

        if self.all_data_inputs_clean():
            msg = self.inputs['msg'].value
            print("LogNode:", msg)  # Example action
        else:
            print("Cannot compute node", self.id, "because inputs are dirty")

        super().postcompute()


class Connection:
    def __init__(self, from_node, from_port, to_node, to_port):
        self.from_node = from_node
        self.from_port = from_port
        self.to_node = to_node
        self.to_port = to_port

    

class NodePort:
    def __init__(self, node,  port_name, port_type, is_control=False):
        self.node = node
        self.port_type = port_type  # PORT_TYPE_INPUT or PORT_TYPE_OUTPUT or (PORT_TYPE_INPUT | PORT_TYPE_OUTPUT)    
        self.port_name = port_name
        self._isDirty = True # Placeholder for dirty flag. If data changes or reqiuires recompute then set to True
        self.value = None  # Placeholder for data value


        self.incoming_connections = []  # List of Connection objects
        self.outgoing_connections = []  # List of Connection objects
        self.connections = []  # List of Connection objects

        if is_control:
            self.port_type |= 0x80  # Set control bit  
    
    def markDirty(self):
        self._isDirty = True

    def markClean(self):
        self._isDirty = False

    def isDirty(self):
        return self._isDirty

    def addConnection(self, connection):
        self.connections.append(connection) 
  
    def isDataPort(self):
        return self.port_type & 0x80 == 0
    
    def isControlPort(self):
        return self.port_type & 0x80 != 0
    
    # TODO: might node need
    def isInputPort(self):
        return (self.port_type & PORT_TYPE_INPUT) == PORT_TYPE_INPUT
    
    # TODO: might not need
    def isOutputPort(self):
        return (self.port_type & PORT_TYPE_OUTPUT) == PORT_TYPE_OUTPUT
    
    def isInputOutputPort(self):
        return (self.port_type & PORT_TYPE_INPUTOUTPUT) == PORT_TYPE_INPUTOUTPUT
    
    def isInputOutputPort(self):
        return (self.port_type & PORT_TYPE_INPUTOUTPUT) == PORT_TYPE_INPUTOUTPUT
    
    #TODO: might not need
    def isOutputInputPort(self):
        return (self.port_type & PORT_TYPE_OUTPUTINPUT) == PORT_TYPE_OUTPUTINPUT
    

    def connectTo(self, other_port):

        print(f"Connecting port '{self.port_name}' on node '{self.node}' to port '{other_port.port_name}' on node '{other_port.node}'")
      
        if self.node == other_port.node:
            # don't do this check if either port is an input/output port
            if not self.isInputOutputPort() and not other_port.isInputOutputPort():
                assert(False)
                raise ValueError("Cannot connect a port to another port on the same node")
                
           
        
        connection = Connection(self.node, self, other_port.node, other_port)

        self.outgoing_connections.append(connection)
        other_port.incoming_connections.append(connection)

        self.addConnection(connection)
        other_port.addConnection(connection)
        #return connection

    # TODO: should this be the default implmentation?
    def setValue(self, value):
        self.value = value
        self._isDirty = False
        for connection in self.connections:
            to_port = connection.to_port
            to_port._isDirty = True  # Mark connected input port as dirty when value changes
            to_port.node.markDirty()  # Mark the node as dirty as well



    # Check to see if my port is dirty. If it is, then 
    def getValue(self):
        
        return self.value
    
    # return the node that owns this port
    def portOwner(self):
        return self.node


class InputNodePort(NodePort):
    def __init__(self, node, port_name, port_type):
        super().__init__(node, port_name, port_type)

        self.incoming_connections = []

class InputDataNodePort(InputNodePort):
    def __init__(self, node, port_name, port_type):
        super().__init__(node, port_name, PORT_TYPE_INPUT)    

        self.incoming_connections = []

class InputControlNodePort(InputNodePort):
    def __init__(self, node, port_name, port_type):
        super().__init__(node, port_name, PORT_TYPE_CONTROL | PORT_TYPE_INPUT)    

        self.incoming_connections = []  


class OutputNodePort(NodePort):
    def __init__(self, node, port_name, port_type):
        super().__init__(node, port_name, PORT_TYPE_OUTPUT)    

        self.outgoing_connections = []

class InputOutputNodePort(NodePort):
    def __init__(self, node, port_name, port_type):
        super().__init__(node, port_name, port_type)    

        self.incoming_connections = []
        self.outgoing_connections = []



# HMMM. do we need these subclasses and do we seperate control/data port types when defining ports on nodes?
class DataPort(NodePort):
    def __init__(self, node, port_name, port_type):
        super().__init__(node, port_name, port_type)
    

    def getDirtyDataNodes(self, port, dirty_nodes = None):
        
        if dirty_nodes is None:
            nodes = []
        else:
            nodes = dirty_nodes


        if port.node is None:
            return []
        
        node = port.node
        #node._isDirty = True # why is this here? it's forcing a recook

        if node.isDataNode() and node._isDirty:
            if node not in nodes:
                nodes.append(node)
            print("  >>>>> Walking dirty node:", node.id, node.isDataNode(), node._isDirty)
            for input_port in node.get_input_data_ports():
                for connection in input_port.connections:
                    node = connection.from_port.node
                    print("  >>>>>>>>>>> Walking input dirty node:", node.id, node.isDataNode(), node._isDirty)
                    # NUST ADDED THESE TWO LINES
                    if node.isDataNode() and node._isDirty:
                       
                        if node not in nodes:
                            nodes.append(node)
                    self.getDirtyDataNodes(connection.from_port, nodes)

               
        return nodes



    #maybe fetch_value() instead.
    # 
    def getValue(self, current_port=None):
        """
        Rules:
        - if a port is clean, I can return the value if it's an input or output port.
        - if a port is an output port and it's dirty, it is an error as it indicates the node that owns it hasn't been
            computed yet.
        - if a port is an input port and it's dirty, then we need to fetch the value from the source port. If the source
            port is dirty, we need to compute the source node first.

        TODO: what happens if this is an input/output port?
        
        """
        if current_port is None:
            current_port = self

        if  current_port.isInputOutputPort():
            
            print("current_port:", current_port.port_name, current_port.port_type)
           
            print("  !!!!!!!!!! Warning: getValue called with current_port being an input/output port", current_port.port_name)
            print(".     !!! connect1ns:", len(current_port.connections))
            if len(current_port.connections) > 0:
                for c in current_port.connections:
                    print(" . (debug)   !!!!!!!!!! connection from port:", c.from_port.port_name)
                print(" .    !!!!!!!!!! Tracing back to source port for input/output port:", current_port.port_name, current_port.connections[0].from_port.port_name)
                result = current_port.getValue(current_port.connections[0].from_port)
                print("  ---------!!!!!!!!!! Setting value for input/output port:", current_port.port_name, "value:", result)
                current_port.value = result
                current_port._isDirty = False
                print("  !!!!!!!!!! Returning value for input/output port:", current_port.port_name, "value:", result)
                return result
            else:
                result = current_port.value
                print("  !!!!!!!!!! Returning value for input/output port:", current_port.port_name, "value:", result)
                return result

        if len(current_port.connections) > 0:
            source_port = current_port.connections[0].from_port

            dirty_nodes =source_port.getDirtyDataNodes(source_port)

            print(".    ######### Dirty nodes that require compute:", [n.id for n in dirty_nodes])
            while dirty_nodes:
                dirty_node = dirty_nodes.pop()
                dirty_node.compute()
                    
       # MARKER
        # it it's an input/output port, we treat it as an input port for now.
        if current_port._isDirty:
            # for a dirty input port, we need to fetch a clean source. It may be that the source node/port is also dirty
            # and we'd have to cook it. If it's clean we can just fetch the value.
            if current_port.isInputPort():
                connections = current_port.connections
                if len(connections) == 0:
                    raise ValueError(f"Cannot get value for port '{self.port_name}' on node '{self.node.id}' because it has no connections")  
                
                # a data input port can/should have only one connection
                assert(len(connections) == 1)
                source_port = connections[0].from_port

                # the source port or node is dirty so we need to compute it first
                if source_port._isDirty or source_port.node._isDirty:
                    
                    #print(".    ######### Dirty nodes that require compute:", [n.id for n in dirty_nodes])
                    source_port.node.compute()
                    # if it's dirty after a compute then the cook either failed or in the async case, it's 
                    # still computing.
                    if not source_port._isDirty:
                        current_port.value = source_port.value
                        current_port._isDirty = False
                    else:
                        raise ValueError(f"Cannot get value for port '{self.port_name}' on node '{self.node.id}' because source port is still dirty")
                else: 
                    # in this case the source port is clean, we can just fetch the value
                    current_port.value = source_port.value
                    current_port._isDirty = False
            else:
                # it's a dirty output port - this is an error
                raise ValueError(f"Cannot get value for output port '{self.port_name}' on node '{self.node.id}' because it is dirty")     
        
        # at this point the port will be clean
        return current_port.value


    def setValue(self, value):
        self.value = value
        self._isDirty = False
        if self.isOutputPort() or self.isOutputInputPort():
            for connection in self.connections:
                to_port = connection.to_port
                print(".      $$$$$$$$$$$$ Setting connected port dirty due to output value change", to_port.port_name, to_port.node.id)
            
                to_port._isDirty = True  # Mark connected input port as dirty when value changes
                to_port.node._isDirty = True  # Mark the node as dirty as well

class ControlPort(NodePort):
    def __init__(self, node, port_name, port_type):
        super().__init__(node, port_name, port_type | 0x80)



    def activate(self):
        # TODO: revisit how activation states should work when forward-cooking the graph. I.E which sides
        # TODO: of the conection gets activated and who is responsible for deactivating ports.
        self.setValue(True)                 # set source port value to active
        for connection in self.connections: # set all the dest porits to active
            to_port = connection.to_port
            to_port.setValue(True)
            # If the connected port is an output/input port, we need to propagate the activation further
            while to_port and to_port.isOutputInputPort():
                to_port = to_port.connections[0].to_port
                to_port.setValue(True)
            # Mark the connected input port as active
        # Placeholder for activating control port
        print(f"Activating control port {self.port_name} on node {self.node.id}")

        #self.setValue(True)
    
    def deactivate(self):
        #for connection in self.connections:
        #    to_port = connection.to_port
        #    to_port.setValue(False)
        # Placeholder for deactivating control port
        print(f"Deactivating control port {self.port_name} on node {self.node.id}")
        self.setValue(False)

    def isActive(self):
        return self.getValue() == True
    

class InputDataPort(DataPort):
    def __init__(self, node, port_name):
        super().__init__(node, port_name, PORT_TYPE_INPUT)

class OutputDataPort(DataPort):
    def __init__(self, node, port_name):
        super().__init__(node, port_name, PORT_TYPE_OUTPUT)

class InputControlPort(ControlPort):
    def __init__(self, node, port_name):
        super().__init__(node, port_name, PORT_TYPE_INPUT | PORT_TYPE_CONTROL)

class OutputControlPort(ControlPort):
    def __init__(self, node, port_name):
        super().__init__(node, port_name, PORT_TYPE_OUTPUT | PORT_TYPE_CONTROL)


class InputOutputDataPort(DataPort):
    def __init__(self, node, port_name):
        super().__init__(node, port_name, PORT_TYPE_INPUTOUTPUT)

class OutputInputDataPort(DataPort):
    def __init__(self, node, port_name):
        super().__init__(node, port_name, PORT_TYPE_OUTPUTINPUT | PORT_TYPE_CONTROL)

class InputOutputControlPort(ControlPort):
    def __init__(self, node, port_name):
        super().__init__(node, port_name, PORT_TYPE_INPUTOUTPUT | PORT_TYPE_CONTROL)




#===================
# IR GENERATOR
#===================

class NodeError(Exception):
    def __init__(self, node_id, message, phase="runtime"):
        self.node_id = node_id
        self.message = message
        self.phase = phase # 'validation', 'compilation', 'runtime'
        super().__init__(f"[{phase}] Node {node_id}: {message}")

    def to_dict(self):
        return {
            "nodeId": self.node_id,
            "message": self.message,
            "phase": self.phase
        }

class IRGenerator:
    def __init__(self):
        self.instructions = []
        self.temp_counter = 0
        self.label_counter = 0
        self.node_results = {} # Cache for data node results (SSA-like)
        self.errors = []

    def error(self, node, message):
        """Log an error and continue if possible, or mark node as broken"""
        self.errors.append(NodeError(node.id, message, "compilation"))

    def new_temp(self):
        self.temp_counter += 1
        return f"t{self.temp_counter}"

    def new_label(self, prefix="L"):
        self.label_counter += 1
        return f"{prefix}_{self.label_counter}"

    def emit(self, op, *args):
        self.instructions.append(f"{op:<12} {', '.join(map(str, args))}")

    def get_input_node(self, node, port_name):
        """Helper to find the node connected to a specific input port"""
        port = node.inputs.get(port_name)
        if port and port.connections:
            return port.connections[0].from_node
        return None

    def get_next_control_node(self, node, port_name):
        """Helper to find the next control node (Deprecated for single output, only returns first)"""
        port = node.outputs.get(port_name)
        if port and port.connections:
            return port.connections[0].to_node
        return None

    def get_next_control_nodes(self, node, port_name):
        """Helper to find ALL next control nodes from a specific port"""
        port = node.outputs.get(port_name)
        if port and port.connections:
            return [conn.to_node for conn in port.connections]
        return []

    def compile_data_node(self, node):
        """Recursively compile data dependencies"""
        try:
            if node.id in self.node_results:
                return self.node_results[node.id]

            result = None

            if node.type == 'ConstInt' or node.type == 'ConstString':

                raise ValueError("ConstInt and ConstString nodes are deprecated. Use Parameter nodes instead.")
                # In a real app, value would be stored in node.data
                # Here we infer from ID or hardcode for demo
                val = "0"
                if "c_0" in node.id: val = "0"
                elif "c_5" in node.id: val = "5"
                elif "c_1" in node.id: val = "1"
                elif "c0" in node.id: val = "0"
                elif "c5" in node.id: val = "5"
                elif "c1" in node.id: val = "1"
                elif "msg" in node.id: val = '"Hello World"'
                
                result = self.new_temp()
                self.emit("CONST", val, "->", result)

            elif node.type == 'Parameter':
                val = str(node.param_value)
                result = self.new_temp()
                self.emit("CONST", val, "->", result)

            elif node.type == 'GetVar':
                raise ValueError("GetVar nodes are deprecated. Use Parameter nodes instead.")
                var_name = "i" # inferred for demo
                result = self.new_temp()
                self.emit("LOAD", var_name, "->", result)

            elif node.type == 'LessThan':
                a = self.compile_data_node(self.get_input_node(node, 'a'))
                b = self.compile_data_node(self.get_input_node(node, 'b'))
                result = self.new_temp()
                self.emit("LT", a, b, "->", result)

            elif node.type == 'Add':
                a = self.compile_data_node(self.get_input_node(node, 'a'))
                b = self.compile_data_node(self.get_input_node(node, 'b'))
                result = self.new_temp()
                self.emit("ADD", a, b, "->", result)

            self.node_results[node.id] = result
            return result
        except Exception as e:
            self.error(node, str(e))
            return self.new_temp()

    def compile_control_flow(self, node, stop_nodes=None):
        """Traverse control flow nodes recursively"""
        if not node:
            return

        if stop_nodes and node in stop_nodes:
            return
        
        # Emit DEBUG_LOC so runtime knows where we are
        self.emit("DEBUG_LOC", node.id)
        
        # Helper to process a standard "next" output that supports multiple connections
        def process_next_nodes(port_name):
            targets = self.get_next_control_nodes(node, port_name)
            for target in targets:
                self.compile_control_flow(target, stop_nodes)

        if node.type == 'Start':
            self.emit("ENTRY")
            process_next_nodes('exec')

        elif node.type == 'SetVar':
            val = self.compile_data_node(self.get_input_node(node, 'val'))
            var_name = "i" 
            self.emit("STORE", var_name, val)
            process_next_nodes('next')

        elif node.type == 'Log':
            msg = self.compile_data_node(self.get_input_node(node, 'msg'))
            self.emit("PRINT", msg)
            process_next_nodes('next')

        elif node.type == 'Message':
            msg = self.compile_data_node(self.get_input_node(node, 'msg'))
            self.emit("PRINT", msg)
            process_next_nodes('next')

        elif node.type == 'If':
            label_false = self.new_label("IF_FALSE")
            label_end = self.new_label("IF_END")
            
            # Condition
            cond = self.compile_data_node(self.get_input_node(node, 'condition'))
            self.emit("BR_FALSE", cond, label_false)
            
            # True Path
            process_next_nodes('true')
            
            self.emit("JUMP", label_end)
            
            # False Path
            self.emit("LABEL", label_false)
            process_next_nodes('false')
            
            self.emit("LABEL", label_end)
            node = None


        elif node.type == 'While':
            loop_start = self.new_label("LOOP_START")
            loop_exit = self.new_label("LOOP_EXIT")

            self.emit("LABEL", loop_start)
            
            # Compile Condition
            cond = self.compile_data_node(self.get_input_node(node, 'condition'))
            self.emit("BR_FALSE", cond, loop_exit)

            # Compile Body
            process_next_nodes('body')
            
            # Loop back
            self.emit("JUMP", loop_start)
            
            # Exit label
            self.emit("LABEL", loop_exit)
            
            # Continue main path
            process_next_nodes('exit')
        
        elif node.type == 'ForLoop' or node.type == 'Loop':
            # 1. Setup
            start_val = self.compile_data_node(self.get_input_node(node, 'start'))
            end_val = self.compile_data_node(self.get_input_node(node, 'end'))
            step_val = self.compile_data_node(self.get_input_node(node, 'step'))
            
            index_var = f"i" # Using 'i' to match existing codegen expectations for now
            
            # 2. Init: index = start
            self.emit("STORE", index_var, start_val)
            
            loop_start = self.new_label("LOOP_START")
            loop_exit = self.new_label("LOOP_EXIT")
            
            self.emit("LABEL", loop_start)
            
            # 3. Condition: index < end
            curr_index_tmp = self.new_temp()
            self.emit("LOAD", index_var, "->", curr_index_tmp)
            
            # Register this temp as the result for the ForLoop node (for 'index' output)
            self.node_results[node.id] = curr_index_tmp
            
            cond_tmp = self.new_temp()
            self.emit("LT", curr_index_tmp, end_val, "->", cond_tmp)
            self.emit("BR_FALSE", cond_tmp, loop_exit)
            
            # 4. Body
            body_targets = self.get_next_control_nodes(node, 'body')
            for target in body_targets:
                self.compile_control_flow(target, stop_nodes=[node])
                
            # 5. Increment: index = index + step
            # We need to load index again to be safe (body might have changed it, though not in this simple case)
            # But we can reuse curr_index_tmp if we assume SSA-ish, but STORE breaks SSA for 'i'.
            # So let's load again or use the temp if we know 'i' wasn't stored to.
            # For safety, let's use the temp we loaded at start of loop.
            next_val_tmp = self.new_temp()
            self.emit("ADD", curr_index_tmp, step_val, "->", next_val_tmp)
            self.emit("STORE", index_var, next_val_tmp)
            
            self.emit("JUMP", loop_start)
            self.emit("LABEL", loop_exit)
            
            # Continue to 'completed' output
            process_next_nodes('completed')

        elif node.type == 'End':
            self.emit("HALT")
            
        else:
            print(f"Unknown control node: {node.type}")


# Run the generator
generator = IRGenerator()
print("--- Generated IR ---")
#generator.compile_control_flow(loop)
#for instr in generator.instructions:
#    print(instr)



class PythonCodeGenerator:
    def __init__(self):
        self.blocks = {}
        self.current_block_name = None
        self.indent = "    "

    def parse_ir(self, instructions):
        # Pass 1: Group instructions into blocks
        current_block = []
        self.current_block_name = "entry" # Default entry block
        
        for line in instructions:
            parts = line.split()
            op = parts[0]
            
            if op == "LABEL":
                # Save previous block
                if self.current_block_name:
                    self.blocks[self.current_block_name] = current_block
                
                # Start new block
                self.current_block_name = parts[1]
                current_block = []
            elif op == "ENTRY":
                continue # Just a marker
            else:
                current_block.append(line)
        
        # Save last block
        if self.current_block_name:
            self.blocks[self.current_block_name] = current_block

    def generate(self):
        code = []
        code.append("def generated_program():")
        code.append(f"{self.indent}# Initialize variables")
        code.append(f"{self.indent}i = 0")
        code.append(f"{self.indent}current_block = 'entry'")
        code.append(f"{self.indent}__active_node_id = None")
        code.append("")
        code.append(f"{self.indent}try:")
        code.append(f"{self.indent}{self.indent}while True:")
        
        block_names = list(self.blocks.keys())
        for i, block_name in enumerate(block_names):
            instrs = self.blocks[block_name]
            code.append(f"{self.indent}{self.indent}{self.indent}if current_block == '{block_name}':")
            
            if not instrs:
                # Handle empty block fallthrough
                if i + 1 < len(block_names):
                    next_block = block_names[i+1]
                    code.append(f"{self.indent}{self.indent}{self.indent}{self.indent}current_block = '{next_block}'")
                    code.append(f"{self.indent}{self.indent}{self.indent}{self.indent}continue")
                else:
                    code.append(f"{self.indent}{self.indent}{self.indent}{self.indent}return")
                continue

            for line in instrs:
                self._emit_instruction(line, code, level=4)
            
            # If block doesn't end with a jump/return, we need to handle fallthrough
            last_op = instrs[-1].split()[0] if instrs else ""
            if last_op not in ["JUMP", "BR_FALSE", "HALT"]:
                if i + 1 < len(block_names):
                    next_block = block_names[i+1]
                    code.append(f"{self.indent}{self.indent}{self.indent}{self.indent}current_block = '{next_block}'")
                    # No continue needed here as it will loop back naturally, 
                    # but explicit continue doesn't hurt and makes intent clear
                else:
                    code.append(f"{self.indent}{self.indent}{self.indent}{self.indent}return")

        code.append(f"{self.indent}except Exception as e:")
        code.append(f"{self.indent}{self.indent}# Re-raise with active node ID context")
        code.append(f"{self.indent}{self.indent}if 'NodeError' in globals():")
        code.append(f"{self.indent}{self.indent}{self.indent}raise NodeError(__active_node_id, str(e))")
        code.append(f"{self.indent}{self.indent}else:")
        code.append(f"{self.indent}{self.indent}{self.indent}# Fallback if NodeError not available")
        code.append(f"{self.indent}{self.indent}{self.indent}raise Exception(f'Error in node {{__active_node_id}}: {{str(e)}}')")

        return "\n".join(code)

    def _emit_instruction(self, line, code, level):
        indent = self.indent * level
        
        # Handle CONST specially to preserve string spaces
        if line.strip().startswith("CONST"):
            # Format: CONST val, ->, dest
            parts = line.split('->')
            # parts[0] is "CONST val, "
            # parts[1] is " dest"
            
            val_part = parts[0].strip()
            # Remove "CONST" prefix
            val_part = val_part[5:].strip()
            # Remove trailing comma if present (from IR formatting)
            if val_part.endswith(','):
                val_part = val_part[:-1]
                
            dest = parts[1].replace(',', '').strip()
            code.append(f"{indent}{dest} = {val_part}")
            return

        parts = [p.strip().replace(',', '') for p in line.split()]
        op = parts[0]
        args = parts[1:]
        
        # Remove '->' arrow from args if present
        args = [a for a in args if a != '->']

        if op == "CONST":
            # Should be handled above, but fallback just in case
            val = args[0]
            dest = args[1]
            code.append(f"{indent}{dest} = {val}")

        elif op == "STORE":
            # STORE var val
            var = args[0]
            val = args[1]
            code.append(f"{indent}{var} = {val}")

        elif op == "LOAD":
            # LOAD var dest
            var = args[0]
            dest = args[1]
            code.append(f"{indent}{dest} = {var}")

        elif op == "LT":
            # LT a b dest
            code.append(f"{indent}{args[2]} = {args[0]} < {args[1]}")

        elif op == "ADD":
            # ADD a b dest
            code.append(f"{indent}{args[2]} = {args[0]} + {args[1]}")

        elif op == "PRINT":
            code.append(f"{indent}print({args[0]})")

        elif op == "BR_FALSE":
            # BR_FALSE cond label
            cond = args[0]
            label = args[1]
            code.append(f"{indent}if not {cond}:")
            code.append(f"{indent}{self.indent}current_block = '{label}'")
            code.append(f"{indent}{self.indent}continue")

        elif op == "JUMP":
            # JUMP label
            label = args[0]
            code.append(f"{indent}current_block = '{label}'")
            code.append(f"{indent}continue")

        elif op == "DEBUG_LOC":
            # DEBUG_LOC node_id
            node_id = args[0]
            code.append(f"{indent}__active_node_id = '{node_id}'")

        elif op == "HALT":
            code.append(f"{indent}return")

# --- Usage ---

# 1. Get the IR from previous step
ir_instructions = generator.instructions

# 2. Generate Python Code
py_gen = PythonCodeGenerator()
py_gen.parse_ir(ir_instructions)
python_source = py_gen.generate()

print("\n--- Generated Python Code ---\n")
print(python_source)

print("\n--- Executing Generated Code ---\n")
exec(python_source)



class AssemblyScriptCodeGenerator:
    def __init__(self):
        self.blocks = {}
        self.current_block_name = None
        self.indent = "  "

    def parse_ir(self, instructions):
        # Reuse the same parsing logic or similar
        current_block = []
        self.current_block_name = "entry"
        
        for line in instructions:
            parts = line.split()
            op = parts[0]
            
            if op == "LABEL":
                if self.current_block_name:
                    self.blocks[self.current_block_name] = current_block
                self.current_block_name = parts[1]
                current_block = []
            elif op == "ENTRY":
                continue
            else:
                current_block.append(line)
        
        if self.current_block_name:
            self.blocks[self.current_block_name] = current_block

    def generate(self):
        code = []
        code.append("export function generated_program(): void {")
        code.append(f"{self.indent}// Initialize variables")
        code.append(f"{self.indent}var i: i32 = 0;")
        code.append(f"{self.indent}var current_block: string = 'entry';")
        
        # Collect and declare all temporary variables to handle scope across blocks
        temp_vars = {} # name -> type
        for instrs in self.blocks.values():
            for line in instrs:
                parts = [p.strip().replace(',', '') for p in line.split()]
                if not parts: continue
                op = parts[0]
                
                if '->' in parts:
                    idx = parts.index('->')
                    if idx + 1 < len(parts):
                        dest = parts[idx+1]
                        if op == 'LT': 
                            temp_vars[dest] = 'boolean'
                        else: 
                            temp_vars[dest] = 'i32'
                elif op == "CONST" and len(parts) >= 2:
                    # CONST val dest (if no arrow)
                    if len(parts) == 3 and parts[1] != '->':
                        temp_vars[parts[2]] = 'i32'
                elif op == "LOAD":
                    # LOAD var dest
                    if len(parts) >= 3:
                        temp_vars[parts[2]] = 'i32'

        for var_name, var_type in sorted(temp_vars.items()):
            default_val = "0" if var_type == "i32" else "false"
            code.append(f"{self.indent}var {var_name}: {var_type} = {default_val};")

        code.append("")
        code.append(f"{self.indent}while (true) {{")
        
        block_names = list(self.blocks.keys())
        for i, block_name in enumerate(block_names):
            instrs = self.blocks[block_name]
            code.append(f"{self.indent}{self.indent}if (current_block == '{block_name}') {{")
            
            if not instrs:
                if i + 1 < len(block_names):
                    next_block = block_names[i+1]
                    code.append(f"{self.indent}{self.indent}{self.indent}current_block = '{next_block}';")
                    code.append(f"{self.indent}{self.indent}{self.indent}continue;")
                else:
                    code.append(f"{self.indent}{self.indent}{self.indent}return;")
                code.append(f"{self.indent}{self.indent}}}")
                continue

            for line in instrs:
                self._emit_instruction(line, code, level=3)
            
            # If block doesn't end with a jump/return, we need to handle fallthrough
            last_op = instrs[-1].split()[0] if instrs else ""
            if last_op not in ["JUMP", "BR_FALSE", "HALT"]:
                if i + 1 < len(block_names):
                    next_block = block_names[i+1]
                    code.append(f"{self.indent}{self.indent}{self.indent}current_block = '{next_block}';")
                else:
                    code.append(f"{self.indent}{self.indent}{self.indent}return;")
            
            # Close block if
            code.append(f"{self.indent}{self.indent}}}")

        code.append(f"{self.indent}}}") # End while
        code.append("}") # End function
        return "\n".join(code)

    def _emit_instruction(self, line, code, level):
        indent = self.indent * level
        
        # Handle CONST specially to preserve string spaces
        if line.strip().startswith("CONST"):
            parts = line.split('->')
            val_part = parts[0].strip()
            val_part = val_part[5:].strip()
            if val_part.endswith(','):
                val_part = val_part[:-1]
            
            dest = parts[1].replace(',', '').strip()
            
            code.append(f"{indent}{dest} = {val_part};")
            return

        parts = [p.strip().replace(',', '') for p in line.split()]
        op = parts[0]
        args = parts[1:]
        args = [a for a in args if a != '->']

        if op == "CONST":
            val = args[0]
            dest = args[1]
            code.append(f"{indent}{dest} = {val};")

        elif op == "STORE":
            var = args[0]
            val = args[1]
            code.append(f"{indent}{var} = {val};")

        elif op == "LOAD":
            var = args[0]
            dest = args[1]
            code.append(f"{indent}{dest} = {var};")

        elif op == "LT":
            code.append(f"{indent}{args[2]} = {args[0]} < {args[1]};")

        elif op == "ADD":
            code.append(f"{indent}{args[2]} = {args[0]} + {args[1]};")

        elif op == "PRINT":
            code.append(f"{indent}console.log({args[0]}.toString());")

        elif op == "BR_FALSE":
            cond = args[0]
            label = args[1]
            code.append(f"{indent}if (!{cond}) {{")
            code.append(f"{indent}{self.indent}current_block = '{label}';")
            code.append(f"{indent}{self.indent}continue;")
            code.append(f"{indent}}}")

        elif op == "JUMP":
            label = args[0]
            code.append(f"{indent}current_block = '{label}';")
            code.append(f"{indent}continue;")

        elif op == "HALT":
            code.append(f"{indent}return;")

# Usage
as_gen = AssemblyScriptCodeGenerator()
as_gen.parse_ir(ir_instructions)
as_source = as_gen.generate()
print("\n--- Generated AssemblyScript Code (Dispatcher) ---\n")
print(as_source)


class RelooperCodeGenerator:
    def __init__(self):
        self.blocks = {}
        self.block_order = []
        self.indent = "  "

    def parse_ir(self, instructions):
        current_block = []
        current_name = "entry"
        self.block_order.append(current_name)
        
        for line in instructions:
            parts = line.split()
            op = parts[0]
            
            if op == "LABEL":
                if current_name:
                    self.blocks[current_name] = current_block
                current_name = parts[1]
                self.block_order.append(current_name)
                current_block = []
            elif op == "ENTRY":
                continue
            else:
                current_block.append(line)
        
        if current_name:
            self.blocks[current_name] = current_block

    def generate(self):
        code = []
        code.append("export function generated_program_optimized(): void {")
        code.append(f"{self.indent}// Initialize variables")
        code.append(f"{self.indent}var i: i32 = 0;")
        
        # Analyze loops (simple heuristic: block jumps to itself)
        loop_headers = set()
        for name, instrs in self.blocks.items():
            if instrs:
                last_instr = instrs[-1]
                parts = last_instr.split()
                if parts[0] == "JUMP" and parts[1] == name:
                    loop_headers.add(name)

        current_indent_level = 1

        for i, block_name in enumerate(self.block_order):
            instrs = self.blocks.get(block_name, [])
            indent = self.indent * current_indent_level

            # If this block is a loop header, start a loop
            if block_name in loop_headers:
                code.append(f"{indent}while (true) {{")
                current_indent_level += 1
                indent = self.indent * current_indent_level

            for line in instrs:
                self._emit_instruction(line, code, current_indent_level, block_name, loop_headers)

            # If this block was a loop header, close it
            if block_name in loop_headers:
                current_indent_level -= 1
                code.append(f"{self.indent * current_indent_level}}}")

        code.append("}")
        return "\n".join(code)

    def _emit_instruction(self, line, code, level, current_block_name, loop_headers):
        indent = self.indent * level
        
        # Handle CONST specially
        if line.strip().startswith("CONST"):
            parts = line.split('->')
            val_part = parts[0].strip()[5:].strip()
            if val_part.endswith(','): val_part = val_part[:-1]
            dest = parts[1].replace(',', '').strip()
            
            is_number = True
            try: float(val_part)
            except ValueError: is_number = False
            type_decl = "i32" if is_number else "string"
            code.append(f"{indent}let {dest}: {type_decl} = {val_part};")
            return

        parts = [p.strip().replace(',', '') for p in line.split()]
        op = parts[0]
        args = parts[1:]
        args = [a for a in args if a != '->']

        if op == "STORE":
            code.append(f"{indent}{args[0]} = {args[1]};")
        elif op == "LOAD":
            code.append(f"{indent}let {args[1]}: i32 = {args[0]};")
        elif op == "LT":
            code.append(f"{indent}let {args[2]}: boolean = {args[0]} < {args[1]};")
        elif op == "ADD":
            code.append(f"{indent}let {args[2]}: i32 = {args[0]} + {args[1]};")
        elif op == "PRINT":
            code.append(f"{indent}console.log({args[0]}.toString());")
        
        elif op == "BR_FALSE":
            cond = args[0]
            target = args[1]
            # If branching to exit, it's a break
            # We assume if we are in a loop header, and we branch elsewhere, it's a break
            if current_block_name in loop_headers:
                code.append(f"{indent}if (!{cond}) break;")
            else:
                # Fallback for non-loop branches (not fully implemented in this simple version)
                code.append(f"{indent}// Branch to {target} (not implemented in simple relooper)")

        elif op == "JUMP":
            target = args[0]
            if target == current_block_name:
                code.append(f"{indent}continue;")
            else:
                 # If jumping to next block, it's a no-op (fallthrough)
                 pass

        elif op == "HALT":
            code.append(f"{indent}return;")

# Usage Relooper
relooper = RelooperCodeGenerator()
relooper.parse_ir(ir_instructions)
relooper_source = relooper.generate()
print("\n--- Generated AssemblyScript Code (Relooper) ---\n")
print(relooper_source)


class PythonRelooperCodeGenerator:
    def __init__(self):
        self.blocks = {}
        self.block_order = []
        self.indent = "    "

    def parse_ir(self, instructions):
        current_block = []
        current_name = "entry"
        self.block_order.append(current_name)
        
        for line in instructions:
            parts = line.split()
            op = parts[0]
            
            if op == "LABEL":
                if current_name:
                    self.blocks[current_name] = current_block
                current_name = parts[1]
                self.block_order.append(current_name)
                current_block = []
            elif op == "ENTRY":
                continue
            else:
                current_block.append(line)
        
        if current_name:
            self.blocks[current_name] = current_block

    def generate(self):
        code = []
        code.append("def generated_program_optimized():")
        code.append(f"{self.indent}# Initialize variables")
        code.append(f"{self.indent}i = 0")
        
        # Analyze loops
        loop_headers = set()
        for name, instrs in self.blocks.items():
            if instrs:
                last_instr = instrs[-1]
                parts = last_instr.split()
                if parts[0] == "JUMP" and parts[1] == name:
                    loop_headers.add(name)

        current_indent_level = 1

        for i, block_name in enumerate(self.block_order):
            instrs = self.blocks.get(block_name, [])
            indent = self.indent * current_indent_level

            # If this block is a loop header, start a loop
            if block_name in loop_headers:
                code.append(f"{indent}while True:")
                current_indent_level += 1
                indent = self.indent * current_indent_level

            for line in instrs:
                self._emit_instruction(line, code, current_indent_level, block_name, loop_headers)

            # If this block was a loop header, close it (dedent)
            if block_name in loop_headers:
                current_indent_level -= 1

        return "\n".join(code)

    def _emit_instruction(self, line, code, level, current_block_name, loop_headers):
        indent = self.indent * level
        
        # Handle CONST specially
        if line.strip().startswith("CONST"):
            parts = line.split('->')
            val_part = parts[0].strip()[5:].strip()
            if val_part.endswith(','): val_part = val_part[:-1]
            dest = parts[1].replace(',', '').strip()
            code.append(f"{indent}{dest} = {val_part}")
            return

        parts = [p.strip().replace(',', '') for p in line.split()]
        op = parts[0]
        args = parts[1:]
        args = [a for a in args if a != '->']

        if op == "STORE":
            code.append(f"{indent}{args[0]} = {args[1]}")
        elif op == "LOAD":
            code.append(f"{indent}{args[1]} = {args[0]}")
        elif op == "LT":
            code.append(f"{indent}{args[2]} = {args[0]} < {args[1]}")
        elif op == "ADD":
            code.append(f"{indent}{args[2]} = {args[0]} + {args[1]}")
        elif op == "PRINT":
            code.append(f"{indent}print({args[0]})")
        
        elif op == "BR_FALSE":
            cond = args[0]
            target = args[1]
            if current_block_name in loop_headers:
                code.append(f"{indent}if not {cond}:")
                code.append(f"{indent}{self.indent}break")
            else:
                code.append(f"{indent}# Branch to {target} (not implemented)")

        elif op == "JUMP":
            target = args[0]
            if target == current_block_name:
                code.append(f"{indent}continue")
            else:
                 pass

        elif op == "HALT":
            code.append(f"{indent}return")

# Usage Python Relooper
py_relooper = PythonRelooperCodeGenerator()
py_relooper.parse_ir(ir_instructions)
py_relooper_source = py_relooper.generate()
print("\n--- Generated Python Code (Relooper) ---\n")
print(py_relooper_source)

print("\n--- Executing Optimized Python Code ---\n")
exec(py_relooper_source)
generated_program_optimized()








# Create Loop Node Network
# Define Nodes
# BEGIN LOOP NETWORK DEFINITION
s = ParamNode('start', 'Parameter', 0)
e = ParamNode('end', 'Parameter', 5)
step = ParamNode('step', 'Parameter', 1)

loop = LoopNode('loop1', 'Loop')

s.connect_output_to('value', loop, 'start')     # inputs to loop node
e.connect_output_to('value', loop, 'end')
step.connect_output_to('value', loop, 'step')   

const_5= ParamNode('ifcompare', 'Parameter', 2)     # if index < 5
lessthan = LessThanNode('lessthan1', 'LessThan')
loop.connect_output_to('index', lessthan, 'a')
const_5.connect_output_to('value', lessthan, 'b')


ifnode = IfNode('ifnode1', 'If')
lessthan.connect_output_to('result', ifnode, 'condition')
loop.connect_output_to('body', ifnode, 'exec')


loopmessage = MessageNode('msgNode', 'Message')
ifnode.connect_output_to('true', loopmessage, 'exec')
loop.connect_output_to('index', loopmessage, 'msg')


#loop.connect_output_to('index', loopmessage, 'msg')

#loop.connect_output_to('body', loopmessage, 'exec')


#loopmessage.connect_output_to('next', loop, 'loop_in')



print("Executing Loop Node Network:")
network = NodeNetwork("LoopNetwork")
loop.get_input_control_port('exec').activate()
network.compute([loop])
# END LOOP NETWORK DEFINITION
#network.compute([loop])

print("\n--- Generating IR from Loop Node Network ---")
generator = IRGenerator()
generator.compile_control_flow(loop)
ir_instructions = generator.instructions
for instr in ir_instructions:
   print(instr)


print("\n--- Exiting ---")

"""
msg_net = MessageNode('msgNodeMain', 'Message')

start = ParamNode('InitParameter', 'Parameter', 2)
nodenet_main = NodeNetwork("MainNodeNetwork")
io_dataport1 = nodenet_main.add_data_inputoutput_port("io_dataport1")
io_dataport1 = nodenet_main.get_data_port("io_dataport1")

io_ctrlport1 = nodenet_main.add_control_inputoutput_port("io_controlport1")


#start.connect_output_to("value", nodenet, "io_dataport1")

# TODO: note that this double connection currently causes two seperate connections. Instead
# TODO: it should be a replacement or an error.
# DONE: currently throws and exception if currently connected.
start.connect_output_to("value", nodenet_main, "io_dataport1")


#odata = OutputDataPort(None, "outdata") 
#odata.setValue(42)
#print("Output Data Port Value:", odata.getValue())

#io_port = InputOutputDataPort(None, "IOPort")

#odata.connectTo(io_port)

# i need to make sure that connect io or oi ports cook coorectly. This means that dirty flags, values are
# properly propagated.
#io_port.setValue(100)
print("IO Port Value after setting ODataPort:", io_port1.getValue())
print("Should not recook", start._isDirty, io_port1._isDirty)

print("IO Port Value after setting ODataPort:", io_port1.getValue())

"""

# 1. Create the main NodeNetwork
network = NodeNetwork("MyNetwork")

# 2. Add the Control Input (Pass-through/Tunnel)
# This port allows control flow to enter the network and trigger internal nodes.
# Note: Using the method exactly as defined in your file (with the typo 'inputouput')
net_exec_port = network.add_control_inputouput_port("exec")

# 3. Add the Param Data Input (Pass-through/Tunnel)
# This port allows data to be passed from outside the network to internal nodes.
net_data_port = network.add_data_inputoutput_port("param_input")

# 4. Create the internal Message Node
msg_node = network.createNode("internal_msg_node", "Message")

# 5. Connect the Network's input ports to the internal Message Node's input ports.
# We use .connectTo() directly here because we are connecting an Input to an Input (Tunneling),
# whereas standard node connections are Output-to-Input.

# Connect Network Control Input -> Message Node Control Input
net_exec_port.connectTo(msg_node.get_input_control_port("exec"))

# Connect Network Data Input -> Message Node Data Input ('msg')
net_data_port.connectTo(msg_node.get_input_data_port("msg"))


param_node = ParamNode("param_node", "Parameter", "Hello from Network!")
param_node.connect_output_to("value", network, "param_input")




print("Network created successfully.")




sys.exit(0)

# 2. Generate Python Code
py_gen = PythonCodeGenerator()
py_gen.parse_ir(ir_instructions)
python_source = py_gen.generate()

print("\n--- Generated Python Code (New Loop) ---\n")
print(python_source)

print("\n--- Executing Generated Python Code ---\n")
exec(python_source)
generated_program()

# 3. Generate AssemblyScript Code
as_gen = AssemblyScriptCodeGenerator()
as_gen.parse_ir(ir_instructions)
as_source = as_gen.generate()

print("\n--- Generated AssemblyScript Code (New Loop) ---\n")
print(as_source)


class AsyncSchedulerAssemblyScriptCodeGenerator:
    def __init__(self):
        self.blocks = {}
        self.block_order = []
        self.block_ids = {}
        self.indent = "  "

    def parse_ir(self, instructions):
        # 1. Parse into Blocks
        current_block = []
        current_name = "entry"
        self.block_order.append(current_name)
        
        for line in instructions:
            parts = line.split()
            op = parts[0]
            
            if op == "LABEL":
                if current_name:
                    self.blocks[current_name] = current_block
                current_name = parts[1]
                self.block_order.append(current_name)
                current_block = []
            elif op == "ENTRY":
                continue
            else:
                current_block.append(line)
        
        if current_name:
            self.blocks[current_name] = current_block

        # 2. Assign Numeric IDs to Blocks for Switch-Case
        for idx, name in enumerate(self.block_order):
            self.block_ids[name] = idx

    def generate(self):
        code = []
        code.append("// --- Async Scheduler Runtime ---")
        code.append("const taskQueue: i32[] = [];")
        code.append("function schedule(blockId: i32): void {")
        code.append(f"{self.indent}taskQueue.push(blockId);")
        code.append("}")
        code.append("")
        
        code.append("export function generated_program_async(): void {")
        code.append(f"{self.indent}// Global State (Context)")
        code.append(f"{self.indent}var i: i32 = 0;")
        
        # Declare Temps
        temp_vars = self._collect_temps()
        for var_name, var_type in sorted(temp_vars.items()):
            default_val = "0" if var_type == "i32" else "false"
            code.append(f"{self.indent}var {var_name}: {var_type} = {default_val};")

        code.append("")
        code.append(f"{self.indent}// Bootstrap")
        code.append(f"{self.indent}schedule({self.block_ids['entry']});")
        code.append("")
        code.append(f"{self.indent}// Scheduler Loop")
        code.append(f"{self.indent}while (taskQueue.length > 0) {{")
        code.append(f"{self.indent}{self.indent}const currentBlockId = taskQueue.shift();")
        code.append(f"{self.indent}{self.indent}switch (currentBlockId) {{")
        
        for i, block_name in enumerate(self.block_order):
            block_id = self.block_ids[block_name]
            instrs = self.blocks.get(block_name, [])
            
            # Identify Fallthrough Block (next in list)
            fallthrough_id = -1
            if i + 1 < len(self.block_order):
                fallthrough_id = self.block_ids[self.block_order[i+1]]

            code.append(f"{self.indent}{self.indent}{self.indent}case {block_id}: // {block_name}")
            
            # Emit Body
            has_scheduler_action = False
            for line in instrs:
                action = self._emit_instruction(line, code, 4, fallthrough_id)
                if action: has_scheduler_action = True

            # Handle implicit fallthrough if no Jump/Branch was emitted
            if not has_scheduler_action and fallthrough_id != -1:
                 code.append(f"{self.indent*4}schedule({fallthrough_id});")
            
            code.append(f"{self.indent*4}break;")
            

        code.append(f"{self.indent}{self.indent}}}") # End Switch
        code.append(f"{self.indent}}}") # End While
        code.append("}") # End Function
        return "\n".join(code)

    def _collect_temps(self):
        temp_vars = {}
        for instrs in self.blocks.values():
            for line in instrs:
                parts = [p.strip().replace(',', '') for p in line.split()]
                if not parts: continue
                op = parts[0]
                if '->' in parts:
                    idx = parts.index('->')
                    if idx + 1 < len(parts):
                        dest = parts[idx+1]
                        temp_vars[dest] = 'boolean' if op == 'LT' else 'i32'
        return temp_vars

    def _emit_instruction(self, line, code, level, fallthrough_id):
        indent = self.indent * level
        
        if line.strip().startswith("CONST"):
            parts = line.split('->')
            val = parts[0].strip()[5:].strip().rstrip(',')
            dest = parts[1].replace(',', '').strip()
            code.append(f"{indent}{dest} = {val};")
            return False

        parts = [p.strip().replace(',', '') for p in line.split()]
        op = parts[0]
        args = [a for a in parts[1:] if a != '->']

        if op == "STORE":
            code.append(f"{indent}{args[0]} = {args[1]};")
            return False
        elif op == "LOAD":
            code.append(f"{indent}{args[1]} = {args[0]};")
            return False
        elif op == "LT":
            code.append(f"{indent}{args[2]} = {args[0]} < {args[1]};")
            return False
        elif op == "ADD":
            code.append(f"{indent}{args[2]} = {args[0]} + {args[1]};")
            return False
        elif op == "PRINT":
            code.append(f"{indent}console.log({args[0]}.toString());")
            return False
        
        elif op == "BR_FALSE":
            cond = args[0]
            target_label = args[1]
            target_id = self.block_ids.get(target_label, -1)
            
            code.append(f"{indent}if (!{cond}) {{")
            code.append(f"{indent}{self.indent}schedule({target_id});")
            code.append(f"{indent}{self.indent}break;")
            code.append(f"{indent}}}")
            return False

        elif op == "JUMP":
            target_label = args[0]
            target_id = self.block_ids.get(target_label, -1)
            code.append(f"{indent}schedule({target_id});")
            return True

        elif op == "HALT":
            code.append(f"{indent}// End of flow")
            return True
            
        return False

# 4. Generate Async Scheduler Code
async_gen = AsyncSchedulerAssemblyScriptCodeGenerator()
async_gen.parse_ir(ir_instructions)
async_source = async_gen.generate()

print("\n--- Generated AssemblyScript Code (Async Scheduler) ---\n")
print(async_source)


class AsyncSchedulerPythonCodeGenerator:
    def __init__(self):
        self.blocks = {}
        self.block_order = []
        self.block_ids = {}
        self.indent = "    "

    def parse_ir(self, instructions):
        # 1. Parse into Blocks
        current_block = []
        current_name = "entry"
        self.block_order.append(current_name)
        
        for line in instructions:
            parts = line.split()
            op = parts[0]
            
            if op == "LABEL":
                if current_name:
                    self.blocks[current_name] = current_block
                current_name = parts[1]
                self.block_order.append(current_name)
                current_block = []
            elif op == "ENTRY":
                continue
            else:
                current_block.append(line)
        
        if current_name:
            self.blocks[current_name] = current_block

        # 2. Assign Numeric IDs to Blocks
        for idx, name in enumerate(self.block_order):
            self.block_ids[name] = idx

    def generate(self):
        code = []
        code.append("import collections")
        code.append("")
        code.append("# --- Async Scheduler Runtime (Python) ---")
        code.append("task_queue = collections.deque()")
        code.append("")
        code.append("def schedule(block_id):")
        code.append(f"{self.indent}task_queue.append(block_id)")
        code.append("")
        
        code.append("def generated_program_async_python():")
        code.append(f"{self.indent}# Global State (Context)")
        code.append(f"{self.indent}i = 0")
        
        # Declare Temps
        temp_vars = self._collect_temps()
        for var_name, var_type in sorted(temp_vars.items()):
            # In Python local vars don't strictly need declaration, but we'll init them 
            # to simulate state persistence across blocks (which would be on 'self' in a class)
            # However, since this whole function runs as a closure, they persist for the while loop scope.
            default_val = "0" if var_type == "i32" else "False"
            code.append(f"{self.indent}{var_name} = {default_val}")

        code.append("")
        code.append(f"{self.indent}# Bootstrap")
        code.append(f"{self.indent}schedule({self.block_ids['entry']})")
        code.append("")
        code.append(f"{self.indent}# Scheduler Loop")
        code.append(f"{self.indent}while task_queue:")
        code.append(f"{self.indent}{self.indent}current_block_id = task_queue.popleft()")
        code.append("")
        
        # Dispatcher
        if_keyword = "if"
        for i, block_name in enumerate(self.block_order):
            block_id = self.block_ids[block_name]
            code.append(f"{self.indent}{self.indent}{if_keyword} current_block_id == {block_id}: # {block_name}")
            if_keyword = "elif"
            
            instrs = self.blocks.get(block_name, [])
            
            # Identify Fallthrough Block
            fallthrough_id = -1
            if i + 1 < len(self.block_order):
                fallthrough_id = self.block_ids[self.block_order[i+1]]

            has_scheduler_action = False
            stmts_start = len(code)

            for line in instrs:
                action = self._emit_instruction(line, code, 3, fallthrough_id)
                if action: has_scheduler_action = True

            # Handle implicit fallthrough
            if not has_scheduler_action and fallthrough_id != -1:
                 code.append(f"{self.indent*3}schedule({fallthrough_id})")
                 has_scheduler_action = True

            if len(code) == stmts_start:
                code.append(f"{self.indent*3}pass")
            
        return "\n".join(code)

    def _collect_temps(self):
        temp_vars = {}
        for instrs in self.blocks.values():
            for line in instrs:
                parts = [p.strip().replace(',', '') for p in line.split()]
                if not parts: continue
                op = parts[0]
                if '->' in parts:
                    idx = parts.index('->')
                    if idx + 1 < len(parts):
                        dest = parts[idx+1]
                        temp_vars[dest] = 'boolean' if op == 'LT' else 'i32'
        return temp_vars

    def _emit_instruction(self, line, code, level, fallthrough_id):
        indent = self.indent * level
        
        if line.strip().startswith("CONST"):
            parts = line.split('->')
            val = parts[0].strip()[5:].strip().rstrip(',')
            dest = parts[1].replace(',', '').strip()
            code.append(f"{indent}{dest} = {val}")
            return False

        parts = [p.strip().replace(',', '') for p in line.split()]
        op = parts[0]
        args = [a for a in parts[1:] if a != '->']

        if op == "STORE":
            code.append(f"{indent}{args[0]} = {args[1]}")
            return False
        elif op == "LOAD":
            code.append(f"{indent}{args[1]} = {args[0]}")
            return False
        elif op == "LT":
            code.append(f"{indent}{args[2]} = {args[0]} < {args[1]}")
            return False
        elif op == "ADD":
            code.append(f"{indent}{args[2]} = {args[0]} + {args[1]}")
            return False
        elif op == "PRINT":
            code.append(f"{indent}print({args[0]})")
            return False
        
        elif op == "BR_FALSE":
            cond = args[0]
            target_label = args[1]
            target_id = self.block_ids.get(target_label, -1)
            
            code.append(f"{indent}if not {cond}:")
            code.append(f"{indent}{self.indent}schedule({target_id})")
            code.append(f"{indent}{self.indent}continue")
            
            # If true, we just fall through to the next instruction in this block
            # No 'else' needed here because we 'continue'd on the if branch
            return False # We return False so the outer loop knows we didn't terminate the block UNCONDITIONALLY

        elif op == "JUMP":
            target_label = args[0]
            target_id = self.block_ids.get(target_label, -1)
            code.append(f"{indent}schedule({target_id})")
            code.append(f"{indent}continue")
            return True

        elif op == "HALT":
            code.append(f"{indent}return")
            return True
            
        return False

# 5. Generate Async Scheduler Code (Python)
async_py_gen = AsyncSchedulerPythonCodeGenerator()
async_py_gen.parse_ir(ir_instructions)
async_py_source = async_py_gen.generate()

print("\n--- Generated Python Code (Async Scheduler) ---\n")
print(async_py_source)

print("\n--- Executing Async Python Code ---\n")
exec(async_py_source)


